<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./assets/style.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </head>
  <body>
    <textarea id="source">

class: center, middle

# Mutation Testing in Action

---

# Code Coverage
Misleading metric

- Detects untested area
- Tells nothing about tested area

Percentage of your code executed by your tests

No behaviours


<div class="red-bg" style="text-align: center;">
  You can have 100% code coverage with no assertions
</div>

---
# 100% Coverage without assertions

1. Imagine you have a code with 100% coverage
2. Now imagine deleting all assertions
3. Run your code coverage tool again
---
# 100% Coverage without assertions

1. Imagine you have a code with 100% coverage
2. Now imagine deleting all assertions
3. Run your code coverage tool again

<div class="red-bg" style="text-align: center;">
  The result? 100% coverage
</div>

---
class: center, middle

# How can we measure the quality of our tests?

---

class: center, middle

# Mutation Testing

---
# Mutation Testing

Modified versions of source code - mutants

Artifical bugs

Created both manually and by frameworks

---

# Code coverage vs Mutation Testing

Code Coverage: how much of the code is executed

Mutation Testing: how much of the code is asserted

---
# Code coverage vs Mutation Testing

Code Coverage: how much the bread is covered

Mutation Testing: what the bread covered with

<div style="text-align: center;">
  <img src="./assets/nutella.webp" alt="Example Image" style="width:500px;">
</div>


---
# Example

```
public bool IsUserOldEnough(User user) {
  return user.Age >= 18;
}
```

---
# Example - Mutation # 1

```
public bool IsUserOldEnough(User user) {
  return user.Age > 18;
}
```

---

# Example - Mutation # 2

```
public bool IsUserOldEnough(User user) {
  return user.Age < 18;
}
```

---
# Example - Mutation # 3

```
public bool IsUserOldEnough(User user) {
  return true;
}
```

---

# Example - Mutation # 3

```
public bool IsUserOldEnough(User user) {
  return false;
}
```
---

# Type of Mutation

Operator Mutations

Conditional Mutations

Statement mutation

Value mutation

<div class= "green-bg" style="text-align: center;">
  Any code change without compilation error.
</div>

---
# Operator Mutations

```
decimal CalculateInterest(decimal principal, decimal rate)
{
    return principal * rate;
}
```

---

# Operator Mutations

```
decimal CalculateInterest(decimal principal, decimal rate)
{
    return principal / rate; 
}

```
---
# Conditional Mutations

```
bool IsHighValueTransaction(decimal amount, decimal threshold)
{
    return amount >= threshold;
}
```
---

# Conditional Mutations

```
bool IsHighValueTransaction(decimal amount, decimal threshold)
{
    return amount < threshold;
}
```

---

# Statement Mutations

```
void ProcessTransaction(User user, decimal amount)
{
    LogTransaction(amount);
    UpdateBalance(amount);
    NotifyUser(user, amount);
}
```
---

# Statement Mutations

```
void ProcessTransaction(User user, decimal amount)
{
    LogTransaction(amount);
*   UpdateBalance(amount);
    NotifyUser(user, amount);
}
```
---

# Value Mutation

```
bool IsEligibleForSeniorAccount(int age)
{
    return age >= 60; 
}
```
---

# Value Mutation

```
bool IsEligibleForSeniorAccount(int age)
{
    return age >= 18; 
}
```
---

# Mutation Score

Measuring the quality of the tests

For every mutant we run all our tests and check if they fail or not

<span class="green-bg"> Killed Mutant</span>: At least one failing test

<span class="red-bg"> Surviving Mutant</span>: No failing test

$$
\text{Mutation Score} = \frac{\text{Number of Killed Mutants}}{\text{Number of All Mutants}} \times 100
$$

---
# Mutation Testing in in .NET

With Stryker
- Best tool in the market
- Perfect for JS/C#/Scala

More info at: https://stryker-mutator.io/


---
class: center, middle

# Demo time: Mutation Testing in Action
---

class: center, middle

# What is the ultimate solution?

---

class: center, middle

# <span class="green-bg">Test-Driven Development</span>

---


class: center, middle

# Law #1

## You are not allowed to write any production code unless it is to make a failing unit test pass

##In other words: 
##<span class="green-bg">Start with a failing test</span>

---

class: center, middle

# Law #2

## You are not allowed to write any more of a unit test than is sufficient to fail, and compilation failures are failures

## In other words: 
## <span class="green-bg">Stop writing your test as soon as it fails or doesn't compile</span>

---

class: center, middle

# Law #3

##You are not allowed to write any more production code than is sufficient to pass the one failing unit test

## In other words: 
##<span class="green-bg">Stop writing production code as soon as the test passes</span>
---

# TDD leads to 100% mutation score

Ensured by the laws of TDD
- 1st law: We only write code if there is a test
- 3rd law: We donâ€™t write more code than sufficient to pass the failing test

Seeing the test failing prevents false negatives.


---
# Conclusion

Without TDD
- you need to use code coverage tools heavily

With TDD
- you need coverage tools only for quality checks

---
class: center, middle

<div class= "green-bg" style="text-align: center; ">
  TDD is the safest and fastest way to write
</div>


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({  
        highlightLanguage: 'cs',
         highlightStyle: 'monokai', highlightLines: true,  ratio: '16:9'});
    </script>
  </body>
</html>
