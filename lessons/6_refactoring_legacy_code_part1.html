<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./assets/style.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </head>
  <body>
    <textarea id="source">

class: center, middle

# Refactoring legacy code

---

class: center, middle

# What is legacy code?
---

class: center, middle

# Legacy is code is simply code without tests - Michael C. Feathers
---

# Working Effectively with Legacy Code

<div style="text-align: center;">
  <img src="./assets/legacy-code-book.png" alt="Example Image", style="width: 550px;">
</div>

---

class: center, middle

# The million dollar quesion:

# <span class="red-bg">How to test legacy code?</span> 

---

# Testing legacy code is simple

1. Identify changes points (Seams)

1. Break dependencies

1. Write tests
  - characetization tests
  - approval tests
  - functional tests
  - mutation testing

1. Write tests for the to achieve ~100 code coverage and mutation score

1. Refactor the code

---

# 1. Identify changes points - Seams

Most legacy code is not testable

The goal is to make it testable.

<div style="text-align: center;" class="orange-bg">

Seams: a place to alter program behaviour, with minimal structural change

</div>
---
# 1. Identify changes points - Seams

TODO: find example with overriding, then also show when we need to do small changes? Or not needed

```
public class OrderService
{
    public decimal GetOrderTotal(int orderId)
    {
        var order = OrderApi.GetOrder(orderId);

        return order.Total;
    }
}
```
---
# 1. Identify changes points - Seams


```
public class OrderService
{
    public decimal GetOrderTotal(int orderId)
    {
*        var order = OrderApi.GetOrder(orderId);

        return order.Total;
    }
}
```
---

# 2. Break dependencies

Abstract away tightly-coupled dependency

Inject a test double like mocks or stubs
---
# 2. Break dependencies

```
public class OrderService
{
    private readonly IOrderRepository _orderRepository;

    public OrderService(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public decimal GetOrderTotal(int orderId)
    {
        var order = _orderRepository.GetOrder(orderId);
        return order.Total;
    }
}
```

---
# 2. Break dependencies

You don't always need to break dependencies at first

Use real dependencies
- if they are not that slow
- crucial for the flow

Break dependencies once everything is tested

---

# 3. Characterization testing - WHY

<div class="red-bg" style="text-align: center;">
  Goal is not to find bugs
</div>

<br>
<div class="green-bg" style="text-align: center;">
  Goal is to understand the behaviours
</div>


---

# 3. Characterization tests - WHEN 

Code is too complex to know what it does

Doesn't have any documnetation

Has no tests

---

# 3. Characterization tests - HOW

1. Create a test
2. Write a failing assertion
3. Execute the test to observe the actual behaviour of the system
4. Change the test that it expects the actual behaviour
5. Repeat until you understand the code well

---

# 3. Characterization tests 

```
public static string FormatText(string text)
{
    var result = new StringBuilder();
    for (int n = 0; n < text.Length; ++n)
    {
        char c = text[n];
        if (c == '<')
        {
            while (n < text.Length && text[n] != '/' && text[n] != '>')
                n++;

            if (n < text.Length && text[n] == '/')
                n += 4;
            else
                n++; 
        }

        if (n < text.Length)
            result.Append(text[n]);
    }

    return result.ToString();
}
```
---

# 1. Create a test
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("plain text");
}

```
---

# 2. Add failing assertion
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("plain text");

  formattedText.Should().Be(null);
}

```
---

# 2. Add failing assertion
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("plain text");

  formattedText.Should().Be(null);
}

```

# 3. Execute test to observe behaviour


Error:
```
Expected formattedText to be <null>, but found "plain text".
```
---
# 4. Change the test

Make it pass

```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("plain text");

  formattedText.Should().Be("plain text");
}
```

---

# 4. Change the test

Capture behaviour

```
[Test]
public void ShouldNotChangeUntaggedText() {
  let formattedText = Pattern.formatText("plain text");

  formattedText.Should().Be("plain text");
}
```

---

# 1. Create a test
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<tag>TDD rocks</tag>");
}

```
---

# 2. Add failing assertion
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<tag>TDD rocks</tag>");

  formattedText.Should().Be(null);
}

```
---

# 2. Add failing assertion
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<tag>TDD rocks</tag>");

  formattedText.Should().Be(null);
}

```

# 3. Execute test to observe behaviour


Error:
```
Expected formattedText to be <null>, but found "TDD rocks"
```
---
# 4. Change the test

Make it pass

```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<tag>TDD rocks</tag>");

  formattedText.Should().Be("TDD rocks");
}
```
---
# 4. Change the test

Capture behaviour

```
[Test]
public void ShouldRemoveOpeningAndClosingTagsFromText() {
  let formattedText = Pattern.formatText("<tag>TDD rocks</tag>");

    formattedText.Should().Be("TDD rocks");
  }
```
---

# 1. Create a test
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<>");
}
```
---
# 2. Add assertion
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<>");

  formattedText.Should().Be("");
}
```
---

# 2. Add assertion
```
[Test]
public void asd() {
  let formattedText = Pattern.formatText("<>");

  formattedText.Should().Be("");
}
```

## <span class="red-bg">But it passes</span>

Is it a bug? Or feature?

- Escalate the issue if necessary
- Leave it there
  - we only document behaviour, no bug finding
- Fix if you are 100% sure it's a bug

---

# Approval testing

- 

TODO: continue

---


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({  
        highlightLanguage: 'cs',
         highlightStyle: 'monokai', highlightLines: true});
    </script>
  </body>
</html>
